<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>小康的学习记录</title><link>https://study.tzki.cn/</link><description>一个收藏回忆与分享技术的地方！</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>sviptzk@163.com (Dreamy.TZK)</managingEditor><webMaster>sviptzk@163.com (Dreamy.TZK)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://study.tzki.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>五、express实战-英雄管理系统</title><link>https://study.tzki.cn/posts/notes/20200703/20200703-2/</link><pubDate>Fri, 03 Jul 2020 14:55:50 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200703/20200703-2/</guid><description><![CDATA[查看源码 后端路由 简单来说，注册路由就是写接口
登录接口 登录接口实现很简单，只需要接收post传来的参数，然后进行验证即可。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const express = require(&#34;express&#34;); const bodyParser = require(&#34;body-parser&#34;); app.use(bodyParser.urlencoded({ extended: false })); // 登录接口 app.post(&#34;/login&#34;, (req, res) =&gt; { // 接收用户传递过来的用户名和密码  let { username, password } = req.body; if (username == &#34;admin&#34; &amp;&amp; password == &#34;123&#34;) { res.send({ code: 200, msg: &#34;登陆成功&#34;, }); } else { res.]]></description></item><item><title>四、node服务器搭建</title><link>https://study.tzki.cn/posts/notes/20200703/20200703-1/</link><pubDate>Fri, 03 Jul 2020 14:55:50 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200703/20200703-1/</guid><description><![CDATA[什么是端口 一台电脑可以部署多个服务器，根据端口不同找到不同的服务器。
默认的http端口为80端口。
web服务器读取网页并返回  使用http模块开启一个服务器 在服务器内部读取文件，将读取到的字符串内容作为服务器的响应返回  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const http = require(&#34;http&#34;); const fs = require(&#34;fs&#34;); const path = require(&#34;path&#34;); const server = http.createServer((req, res) =&gt; { // 拼接路径  const filePath = path.join(__dirname, &#34;index.html&#34;); fs.readFile(filePath, &#34;utf-8&#34;, (err, data) =&gt; { if (err == null) { // 返回页面  res.end(data); } else { res.]]></description></item><item><title>三、NodeJs模块化</title><link>https://study.tzki.cn/posts/notes/20200702/20200702-1/</link><pubDate>Thu, 02 Jul 2020 17:04:50 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200702/20200702-1/</guid><description><![CDATA[内置模块的基本使用(删除文件) 1 2 3 4 5 6 7 8 9 10 11 12  const fs = require(&#34;fs&#34;); /** * 删除文件 * @param {string} &#34;./temp/test.txt&#34; 被删除文件的路径 * @param {function} (err) 回调函数，将错误信息传入其中 */ fs.unlink(&#34;./temp/test.txt&#34;, (err) =&gt; { if (err) throw err; console.log(&#34;已成功删除 test&#34;); });   fs模块读文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const fs = require(&#34;fs&#34;); /** * 读取文件信息 * @date 2020-07-01 * @param {sting} &#34;.]]></description></item><item><title>二、ES6新语法</title><link>https://study.tzki.cn/posts/notes/20200701/20200701-2/</link><pubDate>Wed, 01 Jul 2020 17:05:00 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200701/20200701-2/</guid><description>let关键字 特点 var关键字 let关键字 变量提升 √ × 作用域 没有块级作用域，是函数作用域 有块级作用域 重复声明 √ × 重新赋值 √ √ 变量提升
1 2 console.log(age); let age = 38; 作用域
1 2 3 4 5 for (var i = 0; i &amp;lt; 10; i++) {} console.log(i); for (let n = 0; i &amp;lt; 10; i++) {} console.</description></item><item><title>一、Node.js入门</title><link>https://study.tzki.cn/posts/notes/20200701/20200701-1/</link><pubDate>Wed, 01 Jul 2020 17:04:50 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200701/20200701-1/</guid><description>什么是NodeJs NodeJs是一个基于谷歌V8引擎的运行环境。(服务器上的v8引擎就是node.js)
其作用是让js拥有开发服务端的功能
环境安装 官方地址：https://nodejs.org/zh-cn/
安装完成后，添加环境变量。命令行终端输入node -v即可输出版本号。
同样的，安装完NodeJs之后会自动安装npm（node package manager）。输入npm -v也会出现版本号。
npm可以到NPM去寻找包，类似GitHub。
运行NodeJs VSCode中使用RunCoder插件
终端
注意路径问题，执行命令为node 文件名
VSCode中的终端同理。
双击node.exe，在其内编写代码
服务器端与浏览器端 服务端的JavaScript只有ECMAScript，也就意味着在NodeJs</description></item><item><title>jQuery原理（事件操作相关方法）</title><link>https://study.tzki.cn/posts/notes/20200624/20200615-2/</link><pubDate>Wed, 24 Jun 2020 17:05:00 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200624/20200615-2/</guid><description>on方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 事件操作相关方法 kjQuery.prototype.extend({ on: function (name, callBack) { this.each(function (key, ele) { // 2. 判断当前元素中是否有保存所有事件的对象 if (!ele.eventsCache) { ele.eventsCache = {}; } // 3. 判断对象中有没有对应类型的数组 if (!ele.eventsCache[name]) { ele.eventsCache[name] = []; // 4. 将回调函数添加到数组中 ele.eventsCache[name].push(callBack); // 5. 添加对应类型的事件 kjQuery.addEvent(ele, name, function () { kjQuery.</description></item><item><title>jQuery原理（属性操作相关方法）</title><link>https://study.tzki.cn/posts/notes/20200624/20200615-1/</link><pubDate>Wed, 24 Jun 2020 17:04:50 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200624/20200615-1/</guid><description>attr方法 设置或者获取元素的属性节点值
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //属性操作相关的方法 kjQuery.prototype.extend({ attr: function (attr, value) { // 1. 判断是否是字符串 if (kjQuery.isString(attr)) { if (arguments.length == 1) { return this[0].getAttribute(attr); } else { this.each(function (key, ele) { ele.setAttribute(attr, value); }); } } // 2. 判断是否是对象 else if (kjQuery.isObject(attr)) { var $this = this; // 遍历取出所有属性节点的名称和对应值 $.</description></item><item><title>jQuery原理（DOM操作相关方法）</title><link>https://study.tzki.cn/posts/notes/20200623/</link><pubDate>Tue, 23 Jun 2020 11:35:00 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200623/</guid><description>empty方法 清空指定元素中的所有内容。也就是遍历内容，然后将其innerHTML清空。
1 2 3 4 5 6 7 8 9 10 kjQuery.prototype.extend({ empty: function () { // 遍历所有找到的元素 this.each(function (k, v) { v.innerHTML = &amp;#39;&amp;#39;; }); // 返回this对象为了方便链式编程 return this; }, }) remove方法 删除所有的元素或指定元素。判断是否传入参数，如果传入参数，则删除指定元素，否则删除全部。
JavaScript元素不能自己删除自己，只能通过上级元素删除。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 remove: function (sele) { if (arguments.</description></item><item><title>jQuery原理（原型上的属性、方法）</title><link>https://study.tzki.cn/posts/notes/20200622/</link><pubDate>Mon, 22 Jun 2020 11:35:00 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200622/</guid><description><![CDATA[jQuery原型上的属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  kjQuery.prototype = { constructor: kjQuery, init: function (selector) {}, // 版本号  jquery: &#34;1.1.0&#34;, // 实例默认的选择器取值  selector: &#34;&#34;, // 实例默认的长度  length: 0, // 给实例添加新元素  push: [].push, // 对实例中的元素进行排序  sort: [].sort, // 按照指定下标指定数量删除元素，也可以替换删除的元素  splice: [].splice, };   关于三个方法（push,sort,splice）以push为例：
 通过[].push找到数组的push方法 但是对象的push方法由对象调用，那么this就指向了对象（jQuery） 所以也就相当于[].push.apply(this)将元素添加到对象身上  jQuery原型上的方法 toArray 把实例转换为数组返回
1 2 3  toArray: function () { return [].]]></description></item><item><title>jQuery原理（入口函数）</title><link>https://study.tzki.cn/posts/notes/20200621/</link><pubDate>Sun, 21 Jun 2020 19:42:00 +0800</pubDate><author>Author</author><guid>https://study.tzki.cn/posts/notes/20200621/</guid><description>基本结构 jQuery的基本结构如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 (function (window, undefiend) { var jQuery = function () { return new jQuery.fn.init() } jQuery.prototype = { constructor: jQuery } jQuery.fn.init.prototype = jQuery.prototype window.jQuery = window.$ = jQuery })(window); /* 其中fn指代的是原型，因此以上结构可以转换成以下结构 */ (function (window, undefiend) { var jQuery = function () { return new kjQuery.</description></item></channel></rss>